import { Collection, CollectionManifest, CreateCollectionOptions, RequestConfig, WorkspaceManifest } from '@shared/types';
import { ensureFolderExists } from './util/fs';
import * as vscode from 'vscode';
import yaml from 'yaml';
import semver from 'semver';
import { randomUUID } from 'crypto';
import { createPath, createSlug } from './util';
import EventEmitter from 'node:events';
import createRequestWebview from './createRequestView';
import { TabsManager } from './TabsManager';

type WMEvents = {
    'collection-created': (path: string) => void;
    'request-created': (path: string) => void;
    'collections-updated': (collections: Collection[]) => void;
};

type CreateRequestOptions = {
    /** If false, the collections will not be refreshed and events will not be emited */
    refresh?: boolean;
}

const STORAGE_FOLDER = '.agin-requests';
const VERSION = '1.0.2';

const databaseReadme = `# Agin Requests Database

This database was auto-generated by [Agin Requests](https://requests.agin.rocks). If you want to collaborate, you should include this directory in your version control system. You can learn more about Agin Requests Databases [here](https://docs.requests.agin.rocks/features/git-sync).`;

export class WorkspaceManager {
    private static instance: WorkspaceManager;
    public static folder?: vscode.WorkspaceFolder;
    public static folderIndex?: number;
    private static baseUri?: vscode.Uri;
    public static manifest?: WorkspaceManifest;
    public static collections?: Collection[];
    private static emitter = new EventEmitter();
    private static context?: vscode.ExtensionContext;
    // private static watcher: vscode.FileSystemWatcher;

    private constructor() {
        // WorkspaceManager.watcher = vscode.workspace.createFileSystemWatcher(`**/${STORAGE_FOLDER}/**`);
        // const handler = async (e: vscode.Uri) => {
        //     console.log('File changed', e);
        //     await WorkspaceManager.loadManifest();
        //     await WorkspaceManager.loadCollections();
        // }
        // WorkspaceManager.watcher.onDidChange(handler);
        // WorkspaceManager.watcher.onDidCreate(handler);
        // WorkspaceManager.watcher.onDidDelete(handler);
    }

    public static getInstance(): WorkspaceManager {
        if (!WorkspaceManager.instance) {
            WorkspaceManager.instance = new WorkspaceManager();
        }
        return WorkspaceManager.instance;
    }

    public static isAvaliable(): boolean {
        return !!vscode.workspace.workspaceFolders;
    }

    public static setContext(context: vscode.ExtensionContext) {
        WorkspaceManager.context = context;
    }

    public static async setFolderIndex(index: number): Promise<void> {
        if (WorkspaceManager.folderIndex !== index) TabsManager.closeAllTabs();
        WorkspaceManager.folder = this.getFolders()[index];
        WorkspaceManager.folderIndex = index;
        WorkspaceManager.baseUri = vscode.Uri.joinPath(WorkspaceManager.folder.uri, STORAGE_FOLDER);
        console.log(WorkspaceManager.baseUri);

        await ensureFolderExists(WorkspaceManager.baseUri);
        await this.loadManifest();
        await this.loadCollections();
    }

    public static async loadManifest() {
        if (!WorkspaceManager.baseUri) return;

        const readmePath = vscode.Uri.joinPath(WorkspaceManager.baseUri, 'README.md');
        await vscode.workspace.fs.writeFile(readmePath, Buffer.from(databaseReadme));

        let manifest: WorkspaceManifest | undefined = undefined;
        let manifestPath: vscode.Uri | undefined = undefined;
        try {
            manifestPath = vscode.Uri.joinPath(WorkspaceManager.baseUri, 'manifest.yaml');
            const file = await vscode.workspace.fs.readFile(manifestPath);

            manifest = yaml.parse(file.toString());
        } catch (error) {
            if (error instanceof vscode.FileSystemError) {
                if (error.code == 'FileNotFound' && manifestPath) {
                    manifest = {
                        extensionVersion: VERSION,
                        databaseVersion: 1,
                    };

                    const manifestYaml = yaml.stringify(manifest);
                    await vscode.workspace.fs.writeFile(manifestPath, Buffer.from(manifestYaml));
                }
            }
        }

        if (!manifest) return vscode.window.showErrorMessage('Unable to load manifest');

        if (manifest.databaseVersion > 1) return vscode.window.showErrorMessage('Unsupported database version. Please update Agin Requests in order to open this workspace.');
        if (semver.gt(manifest.extensionVersion, VERSION)) vscode.window.showWarningMessage('This workspace was saved with a newer version of Agin Requests. Some features may not be avaliable.');

        WorkspaceManager.manifest = manifest;
        console.log({ manifest });

        return manifest;
    }

    public static async loadCollections(): Promise<void> {
        if (!WorkspaceManager.baseUri) return;

        const collectionsPath = vscode.Uri.joinPath(WorkspaceManager.baseUri, 'agin-collections');
        await ensureFolderExists(collectionsPath);

        const items = await vscode.workspace.fs.readDirectory(collectionsPath);
        const collectionNames = items.filter(([filename, type]) => type == vscode.FileType.Directory).map(x => x[0]);

        const collections: Collection[] = [];
        for (const col of collectionNames) {
            const colData = await this.readCollection(col);
            if (!colData) continue;

            collections.push(colData);
        }

        WorkspaceManager.collections = collections;

        console.log({ collections });
        WorkspaceManager.emitter.emit('collections-updated', collections);
    }

    public static async createEmptyCollection(path: string) {
        if (!WorkspaceManager.baseUri) return;

        const isLabeledAsFolder = path !== '';

        const collectionName = await vscode.window.showInputBox({
            prompt: `Enter the ${isLabeledAsFolder ? 'folder' : 'collection'} name`,
            placeHolder: `${isLabeledAsFolder ? 'Folder' : 'Collection'} name`,
            validateInput: (input) => {
                if (input == '_collection') return `Choose a different name for the ${isLabeledAsFolder ? 'folder' : 'collection'}.`;
                return null;
            }
        });

        if (!collectionName || collectionName === '_collection') return;

        return await this.createCollection(path, {
            authType: 'none',
            headers: [],
            label: collectionName,
            type: 'collection',
        });
    }

    public static async createCollection(path: string, options: CreateCollectionOptions) {
        if (!WorkspaceManager.baseUri) return;
        const collectionPath = vscode.Uri.joinPath(WorkspaceManager.baseUri, 'agin-collections', path);

        const id = randomUUID();
        const slug = options.slug ?? createSlug(options.label);

        // TODO: Recursively create sub-collections and requests
        const ignoreIds = options.ignoreIds ?? false;
        if (options.children) {
            for (const child of options.children) {
                await this.createCollection(`${path}/${slug}`, { ...child, id: ignoreIds ? randomUUID() : child.id, ignoreIds });
            }
        }

        if (options.requests) {
            for (const request of options.requests) {
                await this.createRequest(`${path}/${slug}`, { ...request, id: ignoreIds ? randomUUID() : request.id });
            }
        }

        const collection: Collection = {
            id,
            slug,
            ...options,
            requests: [],
            children: [],
            path,
        }

        if (collection.slug == '_collection') {
            vscode.window.showErrorMessage('Choose a different name for the collection.');
            return;
        }
        const basePath = vscode.Uri.joinPath(collectionPath, collection.slug);

        await ensureFolderExists(basePath);

        const rawCollection = Buffer.from(yaml.stringify(collection));
        const manifestPath = vscode.Uri.joinPath(basePath, '_collection.yaml');

        await vscode.workspace.fs.writeFile(manifestPath, rawCollection);

        await this.loadCollections();

        WorkspaceManager.emitter.emit('collection-created', manifestPath.toString());

        return collection;
    }

    public static async createRequest(collectionPath: string, requestOptions: RequestConfig, createRequestOptions?: CreateRequestOptions) {
        if (!WorkspaceManager.baseUri) return;
        const noRefresh = createRequestOptions?.refresh === false;

        const slug = requestOptions.slug ?? createSlug(requestOptions.label);

        const request: RequestConfig = this.stripIds({
            slug,
            ...requestOptions,
        })

        if (slug === '_collection') {
            vscode.window.showErrorMessage('Choose a different name for the request.');
            return;
        }
        const basePath = vscode.Uri.joinPath(WorkspaceManager.baseUri, 'agin-collections', collectionPath);
        await ensureFolderExists(basePath);

        const requestPath = vscode.Uri.joinPath(basePath, `${slug}.yaml`);

        const { path: _, ...requestWithoutPath } = request;
        await vscode.workspace.fs.writeFile(requestPath, Buffer.from(yaml.stringify(requestWithoutPath)));

        if (!noRefresh) {
            await this.loadCollections();
            WorkspaceManager.emitter.emit('request-created', requestPath.toString());
        }

        return request;
    }

    public static async renameRequestPrompt(path: string, slug: string) {
        if (!this.baseUri) return;

        const request = await this.readRequest(path, slug);
        if (!request) return;

        const newName = await vscode.window.showInputBox({
            prompt: 'Enter the request name',
            placeHolder: 'Request name',
            value: request.label,
            validateInput: (input) => {
                if (input == '_collection') return 'Choose a different name for the request.';
                if (input == '') return 'Name cannot be empty.';
                return null;
            }
        });
        if (!newName) return;

        await this.renameRequest(path, slug, newName);
    }

    // TODO: Chnage slug
    public static async renameRequest(path: string, slug: string, newName: string) {
        if (!this.baseUri) return;

        const request = await this.readRequest(path, slug);
        if (!request) return;

        const newRequest: RequestConfig = {
            ...request,
            label: newName,
        }

        await this.createRequest(path, newRequest);
        await this.loadCollections();
    }

    private static async readRequest(path: string, slug?: string): Promise<RequestConfig | undefined> {
        if (!this.baseUri) return;
        const uri = vscode.Uri.joinPath(this.baseUri, 'agin-collections', path, slug ? `${slug}.yaml` : '');
        try {
            const requestData = yaml.parse((await vscode.workspace.fs.readFile(uri)).toString()) as RequestConfig;
            const fullRequestData: RequestConfig = this.generateIds({
                ...requestData,
                path: path,
            })
            return fullRequestData;
        } catch (error) {
            return undefined;
        }
    }

    private static async readCollectionManifest(uri: vscode.Uri): Promise<CollectionManifest | undefined> {
        const manifestPath = vscode.Uri.joinPath(uri, '_collection.yaml');
        const manifest = yaml.parse((await vscode.workspace.fs.readFile(manifestPath)).toString()) as CollectionManifest;
        return manifest;
    }

    private static async readCollection(path: string, slug?: string): Promise<Collection | undefined> {
        if (!this.baseUri) return;
        const uri = vscode.Uri.joinPath(this.baseUri, 'agin-collections', path, slug ? `${slug}.yaml` : '');
        console.log('READING');

        console.log({ path, slug });

        try {
            const manifest = await this.readCollectionManifest(uri);
            if (!manifest) return undefined;

            const relativePath = uri.path.split('/agin-collections/')[1]?.split('/').slice(0, -1).join('/') ?? '';

            const items = await vscode.workspace.fs.readDirectory(uri);

            const collections: Collection[] = [];
            const requests: RequestConfig[] = [];
            for (const [col, type] of items) {
                if (col == '_collection.yaml') continue;
                const colPath = vscode.Uri.joinPath(uri, col);

                if (type == vscode.FileType.Directory) {
                    const colData = await this.readCollection(createPath({ path, slug: col }));
                    if (!colData) continue;

                    collections.push(colData);
                } else if (type == vscode.FileType.File) {
                    const reqData = await this.readRequest(createPath({ path, slug: col }));
                    if (!reqData) continue;

                    requests.push(reqData);
                }

            }

            return {
                ...manifest,
                children: collections,
                requests,
                path: relativePath,
            }
        } catch (error) {
            return undefined;
        }
    }

    public static async deleteCollectionConfirm(path: string) {
        const confirm = await vscode.window.showInformationMessage(`Are you sure you want to delete the collection?`, 'Delete', 'Cancel');
        if (confirm !== 'Delete') return;

        await this.deleteCollection(path);
    }

    public static async deleteCollection(path: string) {
        if (!this.baseUri) return;

        const collectionPath = vscode.Uri.joinPath(this.baseUri, 'agin-collections', path);
        await vscode.workspace.fs.delete(collectionPath, { recursive: true });

        await this.loadCollections();
    }

    public static async deleteRequestConfirm(path: string, slug: string) {
        const confirm = await vscode.window.showInformationMessage(`Are you sure you want to delete the request?`, 'Delete', 'Cancel');
        if (confirm !== 'Delete') return;

        await this.deleteRequest(path, slug);
    }

    public static async deleteRequest(path: string, slug: string) {
        if (!this.baseUri) return;

        const requestPath = vscode.Uri.joinPath(this.baseUri, 'agin-collections', path, `${slug}.yaml`);
        await vscode.workspace.fs.delete(requestPath);

        await this.loadCollections();
    }

    // TODO: Chnage slug
    public static async renameCollection(path: string, newName: string) {
        if (!this.baseUri) return;

        const containingPath = path.split('/').slice(0, -1).join('/');

        const collectionPath = vscode.Uri.joinPath(this.baseUri, 'agin-collections', path);
        const collection = await this.readCollection(path);
        if (!collection) return;

        const newCollection: CollectionManifest = {
            ...collection,
            label: newName,
        }

        await this.createCollection(containingPath, newCollection);
        await this.loadCollections();
    }

    public static async renameCollectionPrompt(path: string) {
        if (!this.baseUri) return;

        const collection = await this.readCollection(path);
        if (!collection) return;

        const isLabeledAsFolder = path !== '';

        const newName = await vscode.window.showInputBox({
            prompt: `Enter the ${isLabeledAsFolder ? 'folder' : 'collection'} name`,
            placeHolder: `${isLabeledAsFolder ? 'Folder' : 'Collection'} name`,
            value: collection.label,
            validateInput: (input) => {
                if (input == '_collection') return `Choose a different name for the ${isLabeledAsFolder ? 'folder' : 'collection'}.`;
                if (input == '') return 'Name cannot be empty.';
                return null;
            }
        });
        if (!newName) return;

        await this.renameCollection(path, newName);
    }

    public static async duplicateCollection(path: string) {
        if (!this.baseUri) return;

        const collection = await this.readCollection(path);
        if (!collection) return;

        const containingPath = path.split('/').slice(0, -1).join('/');

        const newName = collection.label + ' Copy';
        const newSlug = createSlug(newName);

        if (await this.readCollection(containingPath, newSlug)) {
            return vscode.window.showErrorMessage('This collection\'s duplicate already exists. Please rename the duplicate and try again.');
        }

        const newCollection: CreateCollectionOptions = {
            ...collection,
            id: randomUUID(),
            label: newName,
            slug: newSlug,
            ignoreIds: true,
        };

        await this.createCollection(containingPath, newCollection);

        await this.loadCollections();

        return newCollection;
    }

    public static async duplicateRequest(path: string, slug: string) {
        if (!this.baseUri) return;

        const request = await this.readRequest(path, slug);
        if (!request) return;

        const newName = request.label + ' Copy';
        const newSlug = createSlug(newName);

        if (await this.readRequest(path, newSlug)) {
            return vscode.window.showErrorMessage('This request\'s duplicate already exists. Please rename the duplicate and try again.');
        }

        const newRequest: RequestConfig = {
            ...request,
            id: randomUUID(),
            label: newName,
            slug: newSlug,
        };

        await this.createRequest(path, newRequest);

        await this.loadCollections();

        return newRequest;
    }

    public static async openRequest(path: string, slug: string) {
        if (!this.baseUri) return;
        if (!WorkspaceManager.context) {
            vscode.window.showErrorMessage('Unable to open request. Please try again. (ERR_NOCONTEXT)');
            return;
        }

        const request = await this.readRequest(path, slug);

        createRequestWebview(WorkspaceManager.context, request);
    }

    public static on<E extends keyof WMEvents>(event: E, listener: WMEvents[E]) {
        WorkspaceManager.emitter.on(event, listener);
    }

    public static off<E extends keyof WMEvents>(event: E, listener: WMEvents[E]) {
        WorkspaceManager.emitter.off(event, listener);
    }

    public static removeListener<E extends keyof WMEvents>(event: E, listener: WMEvents[E]) {
        WorkspaceManager.emitter.removeListener(event, listener);
    }

    public static removeAllListeners<E extends keyof WMEvents>(event?: E) {
        WorkspaceManager.emitter.removeAllListeners(event);
    }

    public static getFolders() {
        if (!this.context) return [];
        const isRemote = !!vscode.env.remoteName;
        return [{ uri: this.context.globalStorageUri, name: isRemote ? 'Remote' : 'Your Device', index: -1 }, ...(vscode.workspace.workspaceFolders ?? [])];
    }

    private static stripListIds(items: any[]) {
        return items.map(item => {
            const { id, ...rest } = item;
            return rest;
        });
    }

    private static stripIds(request: RequestConfig) {
        return {
            ...request,
            headers: this.stripListIds(request.headers),
            params: this.stripListIds(request.params),
            requestBody: typeof request.requestBody === 'object' ? this.stripListIds(request.requestBody) : request.requestBody,
        }
    }

    private static generateListIds(items: any[]) {
        return items.map(item => {
            return {
                ...item,
                id: randomUUID(),
            }
        });
    }

    private static generateIds(request: RequestConfig) {
        return {
            ...request,
            headers: this.generateListIds(request.headers),
            params: this.generateListIds(request.params),
            requestBody: typeof request.requestBody === 'object' ? this.generateListIds(request.requestBody) : request.requestBody,
        }
    }
}

// Usage:
export default WorkspaceManager.getInstance();