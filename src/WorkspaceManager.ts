import { Collection, CollectionManifest, CreateCollectionOptions, RequestConfig, WorkspaceManifest } from '@shared/types';
import { ensureFolderExists } from './util/fs';
import * as vscode from 'vscode';
import yaml from 'yaml';
import semver from 'semver';
import { randomUUID } from 'crypto';
import { createSlug } from './util';

const STORAGE_FOLDER = '.agin-requests';
const VERSION = '1.0.0';

const databaseReadme = `# Agin Requests Database

This database was auto-generated by [Agin Requests](https://requests.agin.rocks). If you want to collaborate, you should include this directory in your version control system. You can learn more about Agin Requests Databases [here](https://docs.requests.agin.rocks/features/git-sync).`;

export class WorkspaceManager {
    private folder?: vscode.WorkspaceFolder;
    private baseUri?: vscode.Uri;
    public manifest?: WorkspaceManifest;
    public collections?: Collection[];

    constructor() {

    }

    // Checks if the workspace is avaliable (for instance if the user has opened a folder)
    isAvaliable() {
        return !!vscode.workspace.workspaceFolders;
    }

    async setFolder(folder: vscode.WorkspaceFolder) {
        this.folder = folder;
        this.baseUri = vscode.Uri.joinPath(folder.uri, STORAGE_FOLDER);
        console.log(this.baseUri);


        await ensureFolderExists(this.baseUri);
        await this.loadManifest();
        await this.loadCollections();
    }

    private async loadManifest() {
        if (!this.baseUri) return;

        const readmePath = vscode.Uri.joinPath(this.baseUri, 'README.md');
        await vscode.workspace.fs.writeFile(readmePath, Buffer.from(databaseReadme));

        let manifest: WorkspaceManifest | undefined = undefined;
        let manifestPath: vscode.Uri | undefined = undefined;
        try {
            manifestPath = vscode.Uri.joinPath(this.baseUri, 'manifest.yaml');
            const file = await vscode.workspace.fs.readFile(manifestPath);

            manifest = yaml.parse(file.toString());
        } catch (error) {
            if (error instanceof vscode.FileSystemError) {
                if (error.code == 'FileNotFound' && manifestPath) {
                    manifest = {
                        extensionVersion: VERSION,
                        databaseVersion: 1,
                    };

                    const manifestYaml = yaml.stringify(manifest);
                    await vscode.workspace.fs.writeFile(manifestPath, Buffer.from(manifestYaml));
                }
            }
        }

        if (!manifest) return vscode.window.showErrorMessage('Unable to load manifest');

        if (manifest.databaseVersion > 1) return vscode.window.showErrorMessage('Unsupported database version. Please update Agin Requests in order to open this workspace.');
        if (semver.gt(manifest.extensionVersion, VERSION)) vscode.window.showWarningMessage('This workspace was saved with a newer version of Agin Requests. Some features may not be avaliable.');

        this.manifest = manifest;
        console.log({ manifest });

        return manifest;
    }

    private async loadCollections() {
        if (!this.baseUri) return;

        const collectionsPath = vscode.Uri.joinPath(this.baseUri, 'agin-collections');
        await ensureFolderExists(collectionsPath);

        const items = await vscode.workspace.fs.readDirectory(collectionsPath);
        const collectionNames = items.filter(([filename, type]) => type == vscode.FileType.Directory).map(x => x[0]);

        const collections: Collection[] = [];
        for (const col of collectionNames) {
            const colPath = vscode.Uri.joinPath(collectionsPath, col);
            const colData = await this.readCollection(colPath);
            if (!colData) continue;

            collections.push(colData);
        }

        this.collections = collections;

        console.log({ collections });
    }

    async createCollection(path: string, options: CreateCollectionOptions) {
        if (!this.baseUri) return;
        const collectionPath = vscode.Uri.joinPath(this.baseUri, path);

        // TODO: Recursively create sub-collections
        const id = randomUUID();
        const slug = createSlug(options.label);

        const collection: Collection = {
            id,
            slug,
            ...options,
            requests: [],
            children: [],
        }

        if (collection.slug == '_collection') return vscode.window.showErrorMessage('Choose a different name for the collection.');
        const basePath = vscode.Uri.joinPath(collectionPath, 'agin-collections', collection.slug);

        await ensureFolderExists(basePath);

        const rawCollection = Buffer.from(yaml.stringify(collection));
        const manifestPath = vscode.Uri.joinPath(basePath, '_collection.yaml');

        await vscode.workspace.fs.writeFile(manifestPath, rawCollection);

        await this.loadCollections();
    };

    async createRequest(collectionPath: string, requestOptions: RequestConfig) {

    }

    private async readRequest(uri: vscode.Uri): Promise<RequestConfig | undefined> {
        const requestData = yaml.parse((await vscode.workspace.fs.readFile(uri)).toString()) as RequestConfig;
        return requestData;
    }

    private async readCollection(uri: vscode.Uri): Promise<Collection | undefined> {
        const manifestPath = vscode.Uri.joinPath(uri, '_collection.yaml');
        const manifest = yaml.parse((await vscode.workspace.fs.readFile(manifestPath)).toString()) as CollectionManifest;

        const items = await vscode.workspace.fs.readDirectory(uri);

        const collections: Collection[] = [];
        const requests: RequestConfig[] = [];
        for (const [col, type] of items) {
            const colPath = vscode.Uri.joinPath(uri, col);

            if (type == vscode.FileType.Directory) {
                const colData = await this.readCollection(colPath);
                if (!colData) continue;

                collections.push(colData);
            } else if (type == vscode.FileType.File) {
                const reqData = await this.readRequest(colPath);
                if (!reqData) continue;

                requests.push(reqData);
            }

        }

        return {
            ...manifest,
            children: collections,
            requests,
        }
    }
}